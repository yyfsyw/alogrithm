Exercise 16.1-4 
假设输入集合是一个以开始时间递增的序列，因此s1 ≤ s2 ≤ · · · ≤ sn. 
如果不是这种情况，那么提前要排序，得用O（nlg(n) ). 
这道题的目标是减少使用教室的数量。
在下面的算法里，活动被指定到有序的教室中。下一个活动将被指派到已经使用过的教室中（如果可能的话）否则，另一个新的教室将被启用。
算法包含两个部分
（1）现在被使用的教室数量L
（2）对于已经被安排过活动的教室的最早结束活动的时间 j, 1 ≤ j ≤ L
 和一个priority queue S (a heap) 来存储现在使用过的增序的 j(在算法导论第三版的section 7.5节里有详细解释)

下面是本题的伪代码：
L = 1;
last(1) = s1 − 1;
INSERT(S, 1);
for i = 1 to n do {
j = MINIMUM(S);
if last(j) > si then
j = L = L + 1; /*number of halls increases by 1*/
else
j = EXTRACT-MIN(S);
schedule activity i in j-th hall;
last(j) = fi;
INSERT(S, j); }

时间需要被安排，每个活动通过heap operations(需要O（lg(L)）) 。 因为最差的情况，每个活动安排在不懂的教室里，我们会有L ≤ n. 
因此，去安排一个活动，我们需要最多O(lg(n)). 与此同时， 所有的活动都可以被安排在O(nlg(n)). 因为排序最初的序列也是需要O(nlg(n)) time， 总时间依然为O(nlg(n))
我们依然需要证明算法的正确性。换句话说，我们需要去表明这个算法什么时候会被终结，数量L 的教室是个最优解。
让我们首先证明一个循环不变量（loop invariant）
“At the end of i-th iteration of the for loop, the number L is the optimal 1 number of halls needed to schedule activities 1, 2, · · · , i”. （使用贪心算法的必要条件）
